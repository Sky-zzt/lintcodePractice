1.bst
BST（Binary Search Tree）目的是为了提高查找的性能，其查找在平均和最坏的情况下都是logn级别，接近二分查找。

其特点是：每个节点的值大于其任意左侧子节点的值，小于其任意右节点的值。
• 中序遍历 in-order traversal 是“ 不下降”序列

介绍三个最基本的操作：

2.平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，
并且左右两个子树都是一棵平衡二叉树。这个方案很好的解决了二叉查找树退化成链表的问题，
把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多

3.但是当我们希望得到二叉树中某一个结点的前驱或者后继结点时，普通的二叉树是无法直接得到的，只能通过遍历一次二叉树得到。
每当涉及到求解前驱或者后继就需要将二叉树遍历一次，非常不方便。----线索二叉树

4.红黑树也是二叉查找树，我们知道，二叉查找树这一数据结构并不难，不算严格的 AVL树（https://blog.csdn.net/u010899985/article/details/80981053）
而红黑树之所以难是难在它是自平衡的二叉查找树，在进行插入和删除等可能会破坏树的平衡的操作时，需要重新自处理达到平衡状态。现在在脑海想下怎么实现？是不是太多情景需要考虑了？啧啧，先别急，通过本文的学习后，你会觉得，其实也不过如此而已。好吧，我们先来看下红黑树的定义和一些基本性质。

RB Tree插入删除只要常数次旋转和log(n)次改颜色，维护平衡信息只要1 bit，其他平衡树一般需要log(n)次旋转，所以效率高一丢丢。
RB Tree相当于特殊的B Tree，B Tree在关系型数据库应用广泛。
红黑树就这么用下来了，没必要改。